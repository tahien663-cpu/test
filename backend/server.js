import express from 'express';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid';
import dotenv from 'dotenv';
import fetch from 'node-fetch';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import xss from 'xss';

const { default: cheerio } = await import('cheerio');

dotenv.config();

// Ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng
const requiredEnvVars = [
  'SUPABASE_URL',
  'SUPABASE_SERVICE_ROLE_KEY',
  'OPENROUTER_API_KEY'
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`L·ªói: ${envVar} ph·∫£i ƒë∆∞·ª£c thi·∫øt l·∫≠p trong file .env`);
    process.exit(1);
  }
}

const app = express();

// Security middleware - Helmet
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://openrouter.ai", "https://image.pollinations.ai", "https://duckduckgo.com"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false, // Disable for API server
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 ph√∫t
  max: 100, // Gi·ªõi h·∫°n m·ªói IP 100 requests per windowMs
  message: {
    error: 'Qu√° nhi·ªÅu y√™u c·∫ßu t·ª´ IP n√†y, vui l√≤ng th·ª≠ l·∫°i sau 15 ph√∫t'
  },
  standardHeaders: true, // Return rate limit info in `RateLimit-*` headers
  legacyHeaders: false, // Disable `X-RateLimit-*` headers
});

// Rate limiting ri√™ng cho c√°c endpoint nh·∫°y c·∫£m
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 ph√∫t
  max: 5, // Gi·ªõi h·∫°n 5 l·∫ßn ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω per IP per 15 ph√∫t
  message: {
    error: 'Qu√° nhi·ªÅu l·∫ßn th·ª≠ ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω, vui l√≤ng th·ª≠ l·∫°i sau 15 ph√∫t'
  },
  skipSuccessfulRequests: true, // Kh√¥ng ƒë·∫øm requests th√†nh c√¥ng
});

const chatLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 ph√∫t
  max: 20, // Gi·ªõi h·∫°n 20 chat messages per minute
  message: {
    error: 'Qu√° nhi·ªÅu tin nh·∫Øn, vui l√≤ng th·ª≠ l·∫°i sau 1 ph√∫t'
  }
});

// Apply rate limiting
app.use(limiter);

// CORS configuration n√¢ng cao
const allowedOrigins = [
  'https://hein1.onrender.com',
  'http://localhost:3000',
  'http://localhost:3001',
  'http://localhost:5173', // Vite default port
  'http://localhost:5174'  // Vite alternative port
];

// Development mode - allow more origins
if (process.env.NODE_ENV === 'development') {
  allowedOrigins.push('http://127.0.0.1:3000', 'http://127.0.0.1:5173');
}

app.use(cors({
  origin: function (origin, callback) {
    // Allow requests with no origin (mobile apps, curl, etc.)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.log(`üö´ CORS blocked origin: ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ['GET', 'POST', 'DELETE', 'PUT', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin'],
  credentials: true,
  optionsSuccessStatus: 200
}));

// Preflight requests
app.options('*', cors());

// Body parsing v·ªõi size limits
app.use(express.json({ 
  limit: '10mb',
  verify: (req, res, buf) => {
    // XSS protection cho JSON payload
    req.rawBody = buf;
  }
}));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY);
const openRouterKey = process.env.OPENROUTER_API_KEY;
const jwtSecret = process.env.JWT_SECRET || 'supersecret-change-in-production';

// Utility function ƒë·ªÉ sanitize input
function sanitizeInput(input) {
  if (typeof input !== 'string') return input;
  return xss(input.trim(), {
    whiteList: {},
    stripIgnoreTag: true,
    stripIgnoreTagBody: ['script']
  });
}

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: 'Hein AI Backend',
    version: '1.0.0',
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Root endpoint v·ªõi API documentation
app.get('/', (req, res) => {
  res.json({ 
    message: 'Hein AI Backend API', 
    version: '1.0.0',
    documentation: {
      endpoints: [
        { method: 'GET', path: '/health', description: 'Health check' },
        { method: 'POST', path: '/api/register', description: 'User registration' },
        { method: 'POST', path: '/api/login', description: 'User login' },
        { method: 'GET', path: '/api/chat/history', description: 'Get chat history' },
        { method: 'POST', path: '/api/chat', description: 'Send chat message' },
        { method: 'POST', path: '/api/generate-image', description: 'Generate image' },
        { method: 'DELETE', path: '/api/chat/:chatId', description: 'Delete chat' },
        { method: 'DELETE', path: '/api/message/:messageId', description: 'Delete message' }
      ],
      rateLimit: {
        general: '100 requests per 15 minutes',
        auth: '5 requests per 15 minutes', 
        chat: '20 requests per minute'
      }
    },
    timestamp: new Date().toISOString()
  });
});

// Request logging middleware
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  const origin = req.get('origin') || 'unknown';
  const userAgent = req.get('user-agent') || 'unknown';
  
  console.log(`üìù ${timestamp} - ${req.method} ${req.path} from ${origin}`);
  
  // Log body size for large requests
  if (req.headers['content-length']) {
    const sizeKB = Math.round(parseInt(req.headers['content-length']) / 1024);
    if (sizeKB > 100) {
      console.log(`üì¶ Large payload: ${sizeKB}KB`);
    }
  }
  
  next();
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('‚ùå Server error:', err);
  
  // CORS error
  if (err.message === 'Not allowed by CORS') {
    return res.status(403).json({ 
      error: 'CORS policy violation',
      message: 'Origin not allowed'
    });
  }
  
  // Rate limit error
  if (err.status === 429) {
    return res.status(429).json({
      error: 'Rate limit exceeded',
      message: err.message
    });
  }
  
  res.status(500).json({ 
    error: 'L·ªói server n·ªôi b·ªô', 
    details: process.env.NODE_ENV === 'development' ? err.message : 'L·ªói kh√¥ng x√°c ƒë·ªãnh',
    timestamp: new Date().toISOString()
  });
});

// Middleware x√°c th·ª±c JWT token
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ 
      error: 'Token kh√¥ng h·ª£p l·ªá',
      code: 'NO_TOKEN'
    });
  }

  try {
    const decoded = jwt.verify(token, jwtSecret);
    req.user = decoded;
    next();
  } catch (err) {
    console.error('üîê JWT verification failed:', err.message);
    
    if (err.name === 'TokenExpiredError') {
      return res.status(403).json({ 
        error: 'Token ƒë√£ h·∫øt h·∫°n',
        code: 'TOKEN_EXPIRED'
      });
    }
    
    return res.status(403).json({ 
      error: 'Token kh√¥ng h·ª£p l·ªá',
      code: 'INVALID_TOKEN'
    });
  }
}

// H√†m retry API v·ªõi exponential backoff
async function retryAPICall(apiCall, maxRetries = 3, initialDelay = 1000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await apiCall();
      
      if (response && response.status !== 429) {
        return response;
      }
      
      if (attempt === maxRetries) {
        throw new Error('ƒê√£ ƒë·∫°t s·ªë l·∫ßn th·ª≠ t·ªëi ƒëa do gi·ªõi h·∫°n t·ª∑ l·ªá');
      }
      
      const retryAfter = response?.headers?.get('retry-after') || response?.headers?.get('x-ratelimit-reset');
      const delay = retryAfter ? parseInt(retryAfter) * 1000 : initialDelay * Math.pow(2, attempt - 1);
      
      console.log(`‚è≥ Rate limited, retrying after ${delay}ms (attempt ${attempt}/${maxRetries})`);
      await new Promise(resolve => setTimeout(resolve, delay));
      
    } catch (err) {
      if (err.name === 'AbortError') {
        console.log('‚èπÔ∏è API request cancelled');
        return null;
      }
      if (attempt === maxRetries) {
        throw err;
      }
      console.warn(`‚ö†Ô∏è Attempt ${attempt} failed:`, err.message);
      await new Promise(resolve => setTimeout(resolve, initialDelay * attempt));
    }
  }
}

// D·ªãch sang ti·∫øng Vi·ªát cho k·∫øt qu·∫£ t√¨m ki·∫øm
async function translateToVietnamese(text) {
  try {
    if (!text || typeof text !== 'string' || text.length > 1000) {
      return text;
    }
    
    const response = await retryAPICall(() => 
      fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openRouterKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://hein-ai.com',
          'X-Title': 'Hein AI',
        },
        body: JSON.stringify({
          model: 'x-ai/grok-4-fast:free',
          messages: [
            {
              role: 'system',
              content: 'B·∫°n l√† tr·ª£ l√Ω d·ªãch thu·∫≠t. D·ªãch vƒÉn b·∫£n sang ti·∫øng Vi·ªát m·ªôt c√°ch ch√≠nh x√°c, t·ª± nhi√™n. Ch·ªâ tr·∫£ v·ªÅ b·∫£n d·ªãch.',
            },
            {
              role: 'user',
              content: `D·ªãch sang ti·∫øng Vi·ªát: ${text}`,
            },
          ],
          temperature: 0.1,
          max_tokens: 300,
          stream: false,
        }),
      })
    );

    if (!response || !response.ok) {
      return text;
    }

    const data = await response.json();
    const translated = data.choices[0]?.message?.content?.trim() || text;
    return translated;
  } catch (err) {
    console.warn('‚ö†Ô∏è Translation failed:', err.message);
    return text;
  }
};

// D·ªãch sang ti·∫øng Anh (ch·ªâ cho t·∫°o ·∫£nh)
async function translateToEnglish(text) {
  try {
    const response = await retryAPICall(() => 
      fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openRouterKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://hein-ai.com',
          'X-Title': 'Hein AI',
        },
        body: JSON.stringify({
          model: 'x-ai/grok-4-fast:free',
          messages: [
            {
              role: 'system',
              content: 'You are a creative translation assistant. Translate to English accurately with descriptive details for image generation. Return only the translation.',
            },
            {
              role: 'user',
              content: `Translate to English for image generation: ${text}`,
            },
          ],
          temperature: 0.2,
          max_tokens: 100,
          stream: false,
        }),
      })
    );

    if (!response || !response.ok) {
      return text;
    }

    const data = await response.json();
    const translated = data.choices[0]?.message?.content?.trim() || text;
    return translated;
  } catch (err) {
    console.warn('‚ö†Ô∏è English translation failed:', err.message);
    return text;
  }
};

// H√†m t√¨m ki·∫øm web v·ªõi gi·ªõi h·∫°n 5 k·∫øt qu·∫£
async function webSearch(query) {
  try {
    const response = await fetch(`https://duckduckgo.com/html/?q=${encodeURIComponent(query)}`, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      },
      timeout: 10000 // 10 second timeout
    });

    if (!response.ok) {
      throw new Error(`Search failed with status ${response.status}`);
    }

    const html = await response.text();
    if (!html) {
      throw new Error('Empty search response');
    }
    
    const $ = cheerio.load(html);
    const results = [];

    // Get max 5 results
    $('.result').slice(0, 5).each((i, el) => {
      const title = $(el).find('.result__title').text().trim();
      let link = $(el).find('.result__url').attr('href') || $(el).find('.result__a').attr('href');
      const snippet = $(el).find('.result__snippet').text().trim();

      if (title && link && snippet && snippet.length > 10) {
        link = link.startsWith('http') ? link : `https://duckduckgo.com${link}`;
        
        // Filter out ads and irrelevant pages
        const excludePatterns = ['ad.', 'sponsor', 'doubleclick', 'shop', 'amazon.com/dp'];
        const isExcluded = excludePatterns.some(pattern => link.includes(pattern));
        
        if (!isExcluded) {
          results.push({
            title: sanitizeInput(title),
            link: link,
            snippet: sanitizeInput(snippet)
          });
        }
      }
    });

    // Translate results to Vietnamese
    const translatedResults = [];
    for (const result of results) {
      const translatedTitle = await translateToVietnamese(result.title);
      const translatedSnippet = await translateToVietnamese(result.snippet);
      translatedResults.push({
        title: translatedTitle,
        link: result.link,
        snippet: translatedSnippet
      });
    }

    return translatedResults;
  } catch (err) {
    console.error('‚ùå Web search error:', err.message);
    return [];
  }
};

// Endpoint ƒëƒÉng k√Ω v·ªõi rate limiting v√† validation
app.post('/api/register', authLimiter, async (req, res) => {
  try {
    let { name, email, password } = req.body;
    
    // Sanitize inputs
    name = sanitizeInput(name);
    email = sanitizeInput(email);
    
    if (!name || !email || !password) {
      return res.status(400).json({ 
        error: 'Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc',
        code: 'MISSING_FIELDS'
      });
    }

    // Validation
    if (name.length < 2 || name.length > 50) {
      return res.status(400).json({ 
        error: 'T√™n ph·∫£i t·ª´ 2-50 k√Ω t·ª±',
        code: 'INVALID_NAME'
      });
    }

    if (password.length < 6 || password.length > 100) {
      return res.status(400).json({ 
        error: 'M·∫≠t kh·∫©u ph·∫£i t·ª´ 6-100 k√Ω t·ª±',
        code: 'INVALID_PASSWORD'
      });
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email) || email.length > 100) {
      return res.status(400).json({ 
        error: 'Email kh√¥ng h·ª£p l·ªá',
        code: 'INVALID_EMAIL'
      });
    }

    const hashedPassword = await bcrypt.hash(password, 12); // Increased rounds for security
    
    const userId = uuidv4();
    const userData = {
      id: userId,
      name: name.trim(),
      email: email.toLowerCase().trim(),
      password: hashedPassword
    };

    const { data: newUser, error } = await supabase
      .from('users')
      .insert(userData)
      .select('id, name, email')
      .single();

    if (error) {
      console.error('‚ùå Supabase error:', error.code, error.message);
      
      if (error.code === '23505' || error.message?.includes('duplicate')) {
        return res.status(409).json({ 
          error: 'Email ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω',
          code: 'EMAIL_EXISTS'
        });
      }
      
      return res.status(500).json({ 
        error: 'L·ªói database', 
        code: 'DATABASE_ERROR',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }

    console.log('‚úÖ User registered successfully:', newUser.email);

    res.status(201).json({ 
      message: 'ƒêƒÉng k√Ω th√†nh c√¥ng!',
      user: { 
        id: newUser.id,
        name: newUser.name, 
        email: newUser.email 
      }
    });

  } catch (err) {
    console.error('‚ùå Registration error:', err);
    res.status(500).json({ 
      error: 'L·ªói server', 
      code: 'SERVER_ERROR',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Endpoint ƒëƒÉng nh·∫≠p v·ªõi rate limiting
app.post('/api/login', authLimiter, async (req, res) => {
  try {
    console.log('üîê Login request from:', req.get('origin'));
    
    let { email, password } = req.body;
    
    // Sanitize inputs
    email = sanitizeInput(email);
    
    if (!email || !password) {
      return res.status(400).json({ 
        error: 'Thi·∫øu email ho·∫∑c m·∫≠t kh·∫©u',
        code: 'MISSING_CREDENTIALS'
      });
    }

    if (email.length > 100 || password.length > 100) {
      return res.status(400).json({ 
        error: 'Th√¥ng tin ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá',
        code: 'INVALID_CREDENTIALS'
      });
    }

    const { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('email', email.toLowerCase().trim())
      .single();

    if (error || !user) {
      console.log('‚ùå User not found:', email);
      return res.status(401).json({ 
        error: 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng',
        code: 'INVALID_CREDENTIALS'
      });
    }

    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      console.log('‚ùå Invalid password for:', email);
      return res.status(401).json({ 
        error: 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng',
        code: 'INVALID_CREDENTIALS'
      });
    }

    const token = jwt.sign(
      { 
        id: user.id, 
        email: user.email,
        iat: Math.floor(Date.now() / 1000)
      }, 
      jwtSecret, 
      { expiresIn: '7d' }
    );
    
    console.log('‚úÖ Login successful for:', email);
    
    res.json({ 
      token, 
      user: { 
        id: user.id,
        name: user.name, 
        email: user.email 
      }
    });
  } catch (err) {
    console.error('‚ùå Login error:', err);
    res.status(500).json({ 
      error: 'L·ªói server', 
      code: 'SERVER_ERROR',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Endpoint l·∫•y l·ªãch s·ª≠ chat
app.get('/api/chat/history', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    console.log('üìö Fetching chat history for user:', userId);

    const { data: chats, error: chatsError } = await supabase
      .from('chats')
      .select('id, title, last_message, timestamp')
      .eq('user_id', userId)
      .order('timestamp', { ascending: false })
      .limit(50); // Limit to 50 recent chats

    if (chatsError) {
      console.error('‚ùå Supabase chats error:', chatsError);
      return res.status(500).json({ 
        error: 'L·ªói truy v·∫•n chats', 
        code: 'DATABASE_ERROR',
        details: process.env.NODE_ENV === 'development' ? chatsError.message : undefined
      });
    }

    if (!chats?.length) {
      return res.json({ history: [] });
    }

    const { data: allMessages, error: msgsError } = await supabase
      .from('messages')
      .select('id, chat_id, role, content, timestamp')
      .in('chat_id', chats.map(c => c.id))
      .order('timestamp', { ascending: true });

    if (msgsError) {
      console.error('‚ùå Supabase messages error:', msgsError);
      return res.status(500).json({ 
        error: 'L·ªói truy v·∫•n messages', 
        code: 'DATABASE_ERROR',
        details: process.env.NODE_ENV === 'development' ? msgsError.message : undefined
      });
    }

    const history = chats.map(chat => ({
      ...chat,
      messages: (allMessages?.filter(m => m.chat_id === chat.id) || []).map(msg => ({
        ...msg,
        content: sanitizeInput(msg.content) // Sanitize message content
      }))
    }));

    console.log(`‚úÖ Returning ${history.length} chats for user ${userId}`);
    res.json({ history });
  } catch (err) {
    console.error('‚ùå Chat history error:', err);
    res.status(500).json({ 
      error: 'L·ªói server', 
      code: 'SERVER_ERROR',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Endpoint chat v·ªõi h·ªó tr·ª£ t√¨m ki·∫øm web v√† rate limiting
app.post('/api/chat', authenticateToken, chatLimiter, async (req, res) => {
  try {
    let { messages, chatId } = req.body;
    
    if (!messages?.length) {
      return res.status(400).json({ 
        error: 'Thi·∫øu messages',
        code: 'MISSING_MESSAGES'
      });
    }

    // Validate and sanitize messages
    if (messages.length > 50) {
      return res.status(400).json({ 
        error: 'Qu√° nhi·ªÅu tin nh·∫Øn trong request',
        code: 'TOO_MANY_MESSAGES'
      });
    }

    messages = messages.map(msg => ({
      role: msg.role === 'user' ? 'user' : 'assistant',
      content: sanitizeInput(msg.content?.slice(0, 4000)) // Limit message length
    })).filter(msg => msg.content && msg.content.length > 0);

    if (!messages.length) {
      return res.status(400).json({ 
        error: 'Kh√¥ng c√≥ tin nh·∫Øn h·ª£p l·ªá',
        code: 'NO_VALID_MESSAGES'
      });
    }

    const userId = req.user.id;
    let currentChatId = chatId;

    console.log(`üí¨ Processing chat request for user ${userId}, chatId: ${currentChatId}`);

    if (!currentChatId) {
      const newChatId = uuidv4();
      const chatTitle = messages[0].content.slice(0, 50) + (messages[0].content.length > 50 ? '...' : '');
      
      const { error: insertError } = await supabase
        .from('chats')
        .insert([{
          id: newChatId,
          user_id: userId,
          title: sanitizeInput(chatTitle),
          last_message: messages[0].content.slice(0, 100),
          timestamp: new Date().toISOString()
        }]);

      if (insertError) {
        console.error('‚ùå Supabase chat insert error:', insertError);
        return res.status(500).json({ 
          error: 'L·ªói t·∫°o chat m·ªõi', 
          code: 'DATABASE_ERROR',
          details: process.env.NODE_ENV === 'development' ? insertError.message : undefined
        });
      }
      currentChatId = newChatId;
      console.log('‚úÖ Created new chat:', newChatId);
    } else {
      // Validate chat ownership
      const { data: chat, error: chatError } = await supabase
        .from('chats')
        .select('id')
        .eq('id', currentChatId)
        .eq('user_id', userId)
        .single();

      if (chatError || !chat) {
        console.error('‚ùå Chat validation error:', chatError);
        return res.status(404).json({ 
          error: 'Kh√¥ng t√¨m th·∫•y chat',
          code: 'CHAT_NOT_FOUND'
        });
      }
    }

    // Prepare messages for AI
    const recentMessages = messages.slice(-15); // Keep last 15 messages for context
    let formattedMessages = [
      {
        role: 'system',
        content: 'B·∫°n l√† Hein, m·ªôt tr·ª£ l√Ω AI th√¥ng minh v√† h·ªØu √≠ch t·ª´ Hein AI. H√£y tr·∫£ l·ªùi t·ª± nhi√™n b·∫±ng ng√¥n ng·ªØ c·ªßa ng∆∞·ªùi d√πng. S·ª≠ d·ª•ng emoji khi ph√π h·ª£p üòä. S·ª≠ d·ª•ng c√¥ng c·ª• web_search khi c·∫ßn th√¥ng tin th·ªùi gian th·ª±c ho·∫∑c khi ng∆∞·ªùi d√πng y√™u c·∫ßu t√¨m ki·∫øm.'
      },
      ...recentMessages
    ];

    const tools = [
      {
        type: 'function',
        function: {
          name: 'web_search',
          description: 'T√¨m ki·∫øm th√¥ng tin tr√™n internet ƒë·ªÉ c√≥ d·ªØ li·ªáu m·ªõi nh·∫•t v√† ch√≠nh x√°c.',
          parameters: {
            type: 'object',
            properties: {
              query: {
                type: 'string',
                description: 'T·ª´ kh√≥a t√¨m ki·∫øm'
              }
            },
            required: ['query']
          }
        }
      }
    ];

    // First AI call
    let openRouterResponse = await retryAPICall(() =>
      fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openRouterKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://hein-ai.com',
          'X-Title': 'Hein AI',
        },
        body: JSON.stringify({
          model: 'x-ai/grok-4-fast:free',
          messages: formattedMessages,
          tools: tools,
          temperature: 0.7,
          max_tokens: 1000,
          stream: false,
        }),
      })
    );

    if (!openRouterResponse) {
      return res.status(499).json({ 
        error: 'Y√™u c·∫ßu b·ªã h·ªßy',
        code: 'REQUEST_CANCELLED'
      });
    }

    if (!openRouterResponse.ok) {
      const errorData = await openRouterResponse.json().catch(() => ({}));
      console.error('‚ùå OpenRouter API error:', errorData);
      return res.status(500).json({ 
        error: 'L·ªói API OpenRouter', 
        code: 'OPENROUTER_ERROR',
        details: errorData.error?.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh' 
      });
    }

    let data = await openRouterResponse.json();
    let aiMessage = data.choices[0]?.message?.content || '';
    const messageId = uuidv4();

    // Handle tool calls (web search)
    if (data.choices[0]?.finish_reason === 'tool_calls' && data.choices[0]?.message?.tool_calls) {
      const toolCalls = data.choices[0].message.tool_calls;
      console.log(`üîç Processing ${toolCalls.length} tool calls`);

      formattedMessages.push(data.choices[0].message);

      for (const toolCall of toolCalls) {
        if (toolCall.function.name === 'web_search') {
          let args;
          try {
            args = JSON.parse(toolCall.function.arguments);
          } catch (parseErr) {
            console.error('‚ùå Tool arguments parse error:', parseErr.message);
            continue;
          }

          console.log('üîç Web search query:', args.query);
          const searchResults = await webSearch(args.query);
          console.log(`üìä Found ${searchResults.length} search results`);

          formattedMessages.push({
            role: 'tool',
            content: JSON.stringify({ 
              results: searchResults.slice(0, 3), // Limit to 3 results to save tokens
              query: args.query,
              timestamp: new Date().toISOString()
            }),
            tool_call_id: toolCall.id,
            name: 'web_search'
          });
        }
      }

      // Second AI call with search results
      const toolResponse = await retryAPICall(() =>
        fetch('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${openRouterKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': 'https://hein-ai.com',
            'X-Title': 'Hein AI',
          },
          body: JSON.stringify({
            model: 'x-ai/grok-4-fast:free',
            messages: formattedMessages,
            temperature: 0.7,
            max_tokens: 1200,
            stream: false,
          }),
        })
      );

      if (!toolResponse) {
        return res.status(499).json({ 
          error: 'Y√™u c·∫ßu b·ªã h·ªßy',
          code: 'REQUEST_CANCELLED'
        });
      }

      if (!toolResponse.ok) {
        const errorData = await toolResponse.json().catch(() => ({}));
        console.error('‚ùå OpenRouter tool response error:', errorData);
        return res.status(500).json({ 
          error: 'L·ªói x·ª≠ l√Ω t√¨m ki·∫øm', 
          code: 'SEARCH_ERROR',
          details: errorData.error?.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh' 
        });
      }

      const toolData = await toolResponse.json();
      aiMessage = toolData.choices[0]?.message?.content || aiMessage;
    }

    // Sanitize AI response
    aiMessage = sanitizeInput(aiMessage);
    
    if (!aiMessage) {
      return res.status(500).json({ 
        error: 'Ph·∫£n h·ªìi AI tr·ªëng',
        code: 'EMPTY_RESPONSE'
      });
    }

    // Save messages to database
    const messagesToSave = [];
    const lastUserMsg = messages[messages.length - 1];
    
    if (lastUserMsg.role === 'user') {
      messagesToSave.push({ 
        id: uuidv4(),
        chat_id: currentChatId, 
        role: 'user', 
        content: lastUserMsg.content, 
        timestamp: new Date().toISOString() 
      });
    }

    messagesToSave.push({ 
      id: messageId,
      chat_id: currentChatId, 
      role: 'ai', 
      content: aiMessage, 
      timestamp: new Date().toISOString() 
    });

    if (messagesToSave.length > 0) {
      const { error: saveError } = await supabase
        .from('messages')
        .insert(messagesToSave);
        
      if (saveError) {
        console.error('‚ùå Error saving messages:', saveError);
        // Don't return error, just log it
      }
    }

    // Update chat metadata
    const { error: updateError } = await supabase
      .from('chats')
      .update({
        last_message: aiMessage.slice(0, 100) + (aiMessage.length > 100 ? '...' : ''),
        timestamp: new Date().toISOString()
      })
      .eq('id', currentChatId);

    if (updateError) {
      console.error('‚ùå Error updating chat:', updateError);
      // Don't return error, just log it
    }

    console.log('‚úÖ Chat response sent successfully');
    res.json({
      message: aiMessage,
      messageId,
      timestamp: new Date().toISOString(),
      model: 'grok-4-fast-free',
      chatId: currentChatId
    });

  } catch (error) {
    console.error('‚ùå Chat API error:', error);
    res.status(500).json({ 
      error: 'L·ªói x·ª≠ l√Ω tin nh·∫Øn', 
      code: 'PROCESSING_ERROR',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Endpoint t·∫°o ·∫£nh v·ªõi Pollinations.ai
app.post('/api/generate-image', authenticateToken, chatLimiter, async (req, res) => {
  try {
    let { prompt, chatId } = req.body;
    
    if (!prompt) {
      return res.status(400).json({ 
        error: 'Prompt l√† b·∫Øt bu·ªôc',
        code: 'MISSING_PROMPT'
      });
    }

    // Sanitize and validate prompt
    prompt = sanitizeInput(prompt);
    if (prompt.length > 500) {
      return res.status(400).json({ 
        error: 'Prompt qu√° d√†i, t·ªëi ƒëa 500 k√Ω t·ª±',
        code: 'PROMPT_TOO_LONG'
      });
    }
    if (prompt.length < 3) {
      return res.status(400).json({ 
        error: 'Prompt qu√° ng·∫Øn, t·ªëi thi·ªÉu 3 k√Ω t·ª±',
        code: 'PROMPT_TOO_SHORT'
      });
    }

    const userId = req.user.id;
    let currentChatId = chatId;

    console.log(`üé® Generating image for user ${userId}, prompt: "${prompt}"`);

    if (!currentChatId) {
      const newChatId = uuidv4();
      const { error: insertError } = await supabase
        .from('chats')
        .insert([{
          id: newChatId,
          user_id: userId,
          title: `T·∫°o ·∫£nh: ${prompt.slice(0, 30)}${prompt.length > 30 ? '...' : ''}`,
          last_message: prompt,
          timestamp: new Date().toISOString()
        }]);

      if (insertError) {
        console.error('‚ùå Supabase chat insert error:', insertError);
        return res.status(500).json({ 
          error: 'L·ªói t·∫°o chat m·ªõi', 
          code: 'DATABASE_ERROR',
          details: process.env.NODE_ENV === 'development' ? insertError.message : undefined
        });
      }
      currentChatId = newChatId;
    } else {
      // Validate chat ownership
      const { data: chat, error: chatError } = await supabase
        .from('chats')
        .select('id')
        .eq('id', currentChatId)
        .eq('user_id', userId)
        .single();

      if (chatError || !chat) {
        console.error('‚ùå Chat validation error:', chatError);
        return res.status(404).json({ 
          error: 'Kh√¥ng t√¨m th·∫•y chat',
          code: 'CHAT_NOT_FOUND'
        });
      }
    }

    // Translate prompt to English for better image generation
    const translatedPrompt = await translateToEnglish(prompt);
    console.log('üî§ Translated prompt:', translatedPrompt);

    // Generate image with Pollinations.ai
    const encodedPrompt = encodeURIComponent(translatedPrompt);
    const timestamp = Date.now();
    const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=1024&height=1024&model=flux&nologo=true&safe=true&seed=${timestamp}`;

    // Test if image URL is accessible
    const pollinationsResponse = await retryAPICall(() =>
      fetch(imageUrl, {
        method: 'HEAD', // Use HEAD to check without downloading
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      })
    );

    if (!pollinationsResponse) {
      return res.status(499).json({ 
        error: 'Y√™u c·∫ßu b·ªã h·ªßy',
        code: 'REQUEST_CANCELLED'
      });
    }

    if (!pollinationsResponse.ok) {
      console.error('‚ùå Pollinations.ai error:', {
        status: pollinationsResponse.status,
        statusText: pollinationsResponse.statusText
      });
      return res.status(500).json({
        error: 'L·ªói t·∫°o ·∫£nh t·ª´ Pollinations.ai',
        code: 'IMAGE_GENERATION_ERROR',
        details: `Status: ${pollinationsResponse.status}`
      });
    }

    const messageId = uuidv4();
    const imageMessage = `üé® **·∫¢nh ƒë√£ t·∫°o:** ${prompt}\n\n![Generated Image](${imageUrl})`;

    // Save messages to database
    const messagesToSave = [
      { 
        id: uuidv4(),
        chat_id: currentChatId, 
        role: 'user', 
        content: prompt, 
        timestamp: new Date().toISOString() 
      },
      { 
        id: messageId,
        chat_id: currentChatId, 
        role: 'ai', 
        content: imageMessage, 
        timestamp: new Date().toISOString() 
      }
    ];

    const { error: saveError } = await supabase
      .from('messages')
      .insert(messagesToSave);

    if (saveError) {
      console.error('‚ùå Error saving image messages:', saveError);
      return res.status(500).json({ 
        error: 'L·ªói l∆∞u tin nh·∫Øn',
        code: 'DATABASE_ERROR',
        details: process.env.NODE_ENV === 'development' ? saveError.message : undefined
      });
    }

    // Update chat metadata
    const { error: updateError } = await supabase
      .from('chats')
      .update({
        last_message: 'H√¨nh ·∫£nh ƒë√£ t·∫°o',
        timestamp: new Date().toISOString()
      })
      .eq('id', currentChatId);

    if (updateError) {
      console.error('‚ùå Error updating chat:', updateError);
      // Don't return error, just log it
    }

    console.log('‚úÖ Image generated successfully');
    res.json({
      message: imageMessage,
      imageUrl: imageUrl,
      messageId,
      timestamp: new Date().toISOString(),
      chatId: currentChatId
    });
  } catch (error) {
    console.error('‚ùå Image generation error:', error);
    res.status(500).json({ 
      error: 'L·ªói t·∫°o ·∫£nh', 
      code: 'IMAGE_ERROR',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Endpoint x√≥a chat
app.delete('/api/chat/:chatId', authenticateToken, async (req, res) => {
  try {
    const { chatId } = req.params;
    const userId = req.user.id;

    const { data: chat, error: chatError } = await supabase
      .from('chats')
      .select('id')
      .eq('id', chatId)
      .eq('user_id', userId)
      .single();

    if (chatError || !chat) {
      console.error('‚ùå Chat validation error:', chatError);
      return res.status(404).json({ 
        error: 'Kh√¥ng t√¨m th·∫•y chat',
        code: 'CHAT_NOT_FOUND'
      });
    }

    // Delete messages first (cascade might not be set up)
    const { error: deleteMessagesError } = await supabase
      .from('messages')
      .delete()
      .eq('chat_id', chatId);

    if (deleteMessagesError) {
      console.error('‚ùå Error deleting messages:', deleteMessagesError);
      return res.status(500).json({ 
        error: 'L·ªói x√≥a tin nh·∫Øn',
        code: 'DATABASE_ERROR',
        details: process.env.NODE_ENV === 'development' ? deleteMessagesError.message : undefined
      });
    }

    // Delete chat
    const { error: deleteError } = await supabase
      .from('chats')
      .delete()
      .eq('id', chatId);

    if (deleteError) {
      console.error('‚ùå Error deleting chat:', deleteError);
      return res.status(500).json({ 
        error: 'L·ªói x√≥a chat',
        code: 'DATABASE_ERROR',
        details: process.env.NODE_ENV === 'development' ? deleteError.message : undefined
      });
    }

    console.log('‚úÖ Chat deleted successfully');
    res.json({ 
      message: 'Chat ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng',
      chatId: chatId
    });
  } catch (err) {
    console.error('‚ùå Delete chat error:', err);
    res.status(500).json({ 
      error: 'L·ªói server', 
      code: 'SERVER_ERROR',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Endpoint x√≥a tin nh·∫Øn
app.delete('/api/message/:messageId', authenticateToken, async (req, res) => {
  try {
    const { messageId } = req.params;
    const userId = req.user.id;

    const { data: message, error: messageError } = await supabase
      .from('messages')
      .select('chat_id')
      .eq('id', messageId)
      .single();

    if (messageError || !message) {
      console.error('‚ùå Message validation error:', messageError);
      return res.status(404).json({ 
        error: 'Kh√¥ng t√¨m th·∫•y tin nh·∫Øn',
        code: 'MESSAGE_NOT_FOUND'
      });
    }

    const { data: chat, error: chatError } = await supabase
      .from('chats')
      .select('id')
      .eq('id', message.chat_id)
      .eq('user_id', userId)
      .single();

    if (chatError || !chat) {
      console.error('‚ùå Chat ownership validation error:', chatError);
      return res.status(404).json({ 
        error: 'Kh√¥ng t√¨m th·∫•y chat li√™n quan',
        code: 'CHAT_NOT_FOUND'
      });
    }

    const { error: deleteError } = await supabase
      .from('messages')
      .delete()
      .eq('id', messageId);

    if (deleteError) {
      console.error('‚ùå Error deleting message:', deleteError);
      return res.status(500).json({ 
        error: 'L·ªói x√≥a tin nh·∫Øn',
        code: 'DATABASE_ERROR',
        details: process.env.NODE_ENV === 'development' ? deleteError.message : undefined
      });
    }

    console.log('‚úÖ Message deleted successfully');
    res.json({ 
      message: 'Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng',
      messageId: messageId
    });
  } catch (err) {
    console.error('‚ùå Delete message error:', err);
    res.status(500).json({ 
      error: 'L·ªói server',
      code: 'SERVER_ERROR', 
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// 404 handler for undefined routes
app.use('*', (req, res) => {
  console.log(`‚ùå 404 - Route not found: ${req.method} ${req.originalUrl}`);
  res.status(404).json({ 
    error: 'Endpoint kh√¥ng t·ªìn t·∫°i',
    code: 'ENDPOINT_NOT_FOUND',
    path: req.originalUrl,
    method: req.method,
    availableEndpoints: [
      'GET /',
      'GET /health',
      'POST /api/register',
      'POST /api/login',
      'GET /api/chat/history',
      'POST /api/chat',
      'POST /api/generate-image',
      'DELETE /api/chat/:chatId',
      'DELETE /api/message/:messageId'
    ]
  });
});

// Graceful shutdown handling
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT received, shutting down gracefully');
  process.exit(0);
});

// Unhandled promise rejection handling
process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
  // Don't exit the process in production
  if (process.env.NODE_ENV === 'development') {
    process.exit(1);
  }
});

// Uncaught exception handling
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  process.exit(1);
});

// Kh·ªüi ƒë·ªông server
const PORT = process.env.PORT || 3001;
const HOST = process.env.NODE_ENV === 'production' ? '0.0.0.0' : 'localhost';

const server = app.listen(PORT, HOST, () => {
  console.log('üöÄ================================üöÄ');
  console.log('üåü HEIN AI BACKEND SERVER STARTED üåü');
  console.log('üöÄ================================üöÄ');
  console.log(`üìç Server: http://${HOST}:${PORT}`);
  console.log(`üåç External: http://0.0.0.0:${PORT}`);
  console.log(`üì± Frontend: https://hein1.onrender.com`);
  console.log(`üîç Health: http://${HOST}:${PORT}/health`);
  console.log(`üîß Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`‚ö° Node.js: ${process.version}`);
  console.log(`üìä Memory: ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB`);
  console.log('üöÄ================================üöÄ');
});

// Server timeout settings
server.timeout = 120000; // 2 minutes
server.keepAliveTimeout = 65000; // 65 seconds
server.headersTimeout = 66000; // 66 seconds
